<!doctype html>
<html><head><meta charset="utf-8"><title>Simulation</title>
<link rel="stylesheet" href="/css/style.css"></head><body>
<div class="container">
  <h2>Simulation 3D</h2>
  <div id="sim_container" style="width:100%; height:600px;"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://unpkg.com/cannon-es/dist/cannon-es.js"></script>

<script>
  let scene, camera, renderer, world, robots=[];
  function init(){
    const container = document.getElementById('sim_container');
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, container.clientWidth/container.clientHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);
    camera.position.set(0,10,15); camera.lookAt(0,0,0);
    const light = new THREE.DirectionalLight(0xffffff,1); light.position.set(10,10,5); scene.add(light);
    // ground
    const g = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({color:0x808080})); g.rotation.x = -Math.PI/2; scene.add(g);
    world = new CANNON.World(); world.gravity.set(0,-9.82,0);
    const groundBody = new CANNON.Body({mass:0, shape:new CANNON.Plane()}); groundBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(groundBody);

    for(let i=0;i<4;i++) addRobot(i*2 - 3,1,0);
    animate();
  }

  function addRobot(x,y,z){
    const geo = new THREE.BoxGeometry(1,1,1); const mat = new THREE.MeshStandardMaterial({color: Math.random()*0xffffff});
    const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x,y,z); scene.add(mesh);
    const body = new CANNON.Body({mass:1, shape: new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5)), position: new CANNON.Vec3(x,y,z)});
    world.addBody(body);
    const id = robots.length; robots.push({id,mesh,body});
    return id;
  }

  function animate(){
    requestAnimationFrame(animate);
    world.step(1/60);
    robots.forEach(r=>{ r.mesh.position.copy(r.body.position); r.mesh.quaternion.copy(r.body.quaternion); });
    renderer.render(scene, camera);
  }

  // simple API exposed to blocks
  const robot_api = {
    move: function(dist, robotIndex=0){
      const r = robots[robotIndex]; if(!r) return;
      const forward = new CANNON.Vec3(0,0,-1);
      r.body.applyImpulse(forward.scale(dist*0.5), r.body.position);
    },
    turn: function(angleDeg, robotIndex=0){
      const r = robots[robotIndex]; if(!r) return;
      r.body.angularVelocity.set(0, angleDeg * 0.02, 0);
    }
  };

  window.addEventListener('message', (ev)=>{
    if(ev.data && ev.data.type === 'run_code'){
      const code = ev.data.code;
      try{
        const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
        const fn = new AsyncFunction('robot_api', code);
        fn(robot_api).catch(e=>console.error(e));
      } catch(e){ console.error(e); }
    }
  }, false);

  init();
</script>
</body></html>
