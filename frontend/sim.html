<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Simulateur 3D Robots — B & C</title>

<style>
  body{margin:0;background:#111;color:#fff;font-family:Arial}
  h2{margin:0;padding:10px;background:#222;color:#0af;border-bottom:2px solid #0af}
  #toolbar{padding:10px;background:#000;border-bottom:1px solid #333}
  #toolbar button{padding:8px 14px;margin-right:6px;background:#0af;border:none;color:#fff;border-radius:4px;cursor:pointer}
  #toolbar button:hover{background:#08c}
  #sim_container{width:100%;height:600px;position:relative;background:#000}
  canvas{background:#000;display:block;margin:auto}

  /* Zone Blockly */
  #blocklyDiv{
    position:fixed;
    top:70px; right:10px;
    width:420px;
    height:580px;
    background:#222;
    border:2px solid #0af;
    border-radius:8px;
  }
  #runBtn{
    position:fixed;
    top: 10px;
    right: 10px;
    background:#0f0;
    padding:10px 16px;
    border:none;
    border-radius:6px;
    color:#000;
    cursor:pointer;
    font-weight:bold;
    font-size:16px;
  }
  #runBtn:hover{ background:#9f9; }

  #robotSelect{
    position:fixed;
    top: 10px;
    right:130px;
    padding:8px;
    border-radius:4px;
  }
</style>

<!-- Blockly officiel -->
<script src="https://unpkg.com/blockly/blockly.min.js"></script>

</head>

<body>
<h2>Simulateur 3D — Robots B & C</h2>

<div id="toolbar">
  <button onclick="addRobotB()">➕ Ajouter Robot B (Wall-E)</button>
  <button onclick="addRobotC()">➕ Ajouter Robot C (Futuriste)</button>
  <button onclick="resetSim()">♻ Réinitialiser</button>
</div>

<!-- Sélecteur de robot + bouton Play -->
<select id="robotSelect"></select>
<button id="runBtn" onclick="runBlockly()">▶ PLAY</button>

<div id="sim_container">
  <canvas id="sim" width="800" height="600"></canvas>
</div>

<!-- Zone Blockly -->
<div id="blocklyDiv"></div>

<script>
/* ------------------------------------------------------------
   TON SIMULATEUR D'ORIGINE — INTACT
------------------------------------------------------------ */

const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");

let camX = 0;
let camY = 0;
let camZoom = 1;
let camRot = 0;

let isRightDragging = false;
let isLeftDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;

let robots = [];

function createRobotB(){
  return {
    type:"B",
    x: Math.random()*500+100,
    y: Math.random()*300+150,
    angle: 0,
    size: 40,
    color:"#ffdd66",
    wheelsColor:"#444",
    eyeColor:"#fff"
  };
}

function createRobotC(){
  return {
    type:"C",
    x: Math.random()*500+100,
    y: Math.random()*300+150,
    angle: 0,
    size: 45,
    color:"#66aaff",
    neon:"#0ff"
  };
}

function addRobotB(){ robots.push(createRobotB()); updateRobotDropdown(); }
function addRobotC(){ robots.push(createRobotC()); updateRobotDropdown(); }
function resetSim(){ robots = []; updateRobotDropdown(); }

window.robot_api = {
  move: async function(id, dist){
    const r = robots[id];
    if(!r) return;
    const steps = 20;
    const dx = Math.cos(r.angle)*dist/steps;
    const dy = Math.sin(r.angle)*dist/steps;
    for(let i=0;i<steps;i++){
      r.x += dx;
      r.y += dy;
      await new Promise(res=>setTimeout(res,20));
    }
  },
  turn: async function(id, deg){
    const r = robots[id];
    if(!r) return;
    const steps = 20;
    const da = deg*Math.PI/180/steps;
    for(let i=0;i<steps;i++){
      r.angle += da;
      await new Promise(res=>setTimeout(res,20));
    }
  }
};

function drawRobotB(r){
  ctx.save();
  ctx.translate(r.x, r.y);
  ctx.rotate(r.angle);
  ctx.fillStyle = r.color;
  ctx.fillRect(-r.size/2, -r.size/2, r.size, r.size);
  ctx.fillRect(-r.size/3, -r.size*0.9, r.size*0.66, r.size*0.5);
  ctx.fillStyle = r.eyeColor;
  ctx.beginPath();
  ctx.arc(-10, -r.size*0.7, 6, 0, Math.PI*2);
  ctx.arc(10, -r.size*0.7, 6, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = r.wheelsColor;
  ctx.fillRect(-r.size/2-6, -r.size/3, 6, r.size*0.66);
  ctx.fillRect(r.size/2, -r.size/3, 6, r.size*0.66);
  ctx.restore();
}

function drawRobotC(r){
  ctx.save();
  ctx.translate(r.x, r.y);
  ctx.rotate(r.angle);
  ctx.fillStyle = r.color;
  ctx.beginPath();
  ctx.moveTo(0, -r.size/1.2);
  ctx.lineTo(-r.size/1.3, r.size/1.2);
  ctx.lineTo(r.size/1.3, r.size/1.2);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = r.neon;
  ctx.fillRect(-8, -r.size*0.2, 16, 6);
  ctx.restore();
}

canvas.addEventListener("contextmenu", e => e.preventDefault());
canvas.addEventListener("mousedown", e => {
  if(e.button === 2) isRightDragging = true;
  if(e.button === 0) isLeftDragging = true;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});
canvas.addEventListener("mouseup", e => {
  if(e.button === 2) isRightDragging = false;
  if(e.button === 0) isLeftDragging = false;
});
canvas.addEventListener("mousemove", e => {
  const dx = e.clientX-lastMouseX;
  const dy = e.clientY-lastMouseY;
  if(isRightDragging){
    camX += dx/camZoom;
    camY += dy/camZoom;
  }
  if(isLeftDragging) camRot += dx*0.01;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});
canvas.addEventListener("wheel", e=>{
  if(e.deltaY<0) camZoom*=1.1;
  else camZoom/=1.1;
});

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.scale(camZoom, camZoom);
  ctx.rotate(camRot);
  ctx.translate(-canvas.width/2+camX, -canvas.height/2+camY);
  robots.forEach(r=>{
    if(r.type==="B") drawRobotB(r);
    if(r.type==="C") drawRobotC(r);
  });
  ctx.restore();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ------------------------------------------------------------
   BLOCKLY — BLOCS + TOOLBOX + PLAY
------------------------------------------------------------ */

// Définition des blocs AVANT injection
Blockly.defineBlocksWithJsonArray([
  {
    "type": "move_forward",
    "message0": "avancer de %1",
    "args0": [{"type":"field_number","name":"DIST","value":50}],
    "previousStatement": null,
    "nextStatement": null,
    "colour": 120
  },
  {
    "type": "turn_left",
    "message0": "tourner à gauche de %1°",
    "args0": [{"type":"field_number","name":"ANGLE","value":90}],
    "previousStatement": null,
    "nextStatement": null,
    "colour": 200
  },
  {
    "type": "turn_right",
    "message0": "tourner à droite de %1°",
    "args0": [{"type":"field_number","name":"ANGLE","value":90}],
    "previousStatement": null,
    "nextStatement": null,
    "colour": 200
  }
]);

// Génération de code JS
Blockly.JavaScript['move_forward'] = block =>
  `await robot_api.move(selectedRobotId, ${block.getFieldValue('DIST')} );\n`;

Blockly.JavaScript['turn_left'] = block =>
  `await robot_api.turn(selectedRobotId, -${block.getFieldValue('ANGLE')});\n`;

Blockly.JavaScript['turn_right'] = block =>
  `await robot_api.turn(selectedRobotId, ${block.getFieldValue('ANGLE')});\n`;

// Toolbox
const toolbox = `
<xml xmlns="https://developers.google.com/blockly/xml">
  <category name="Déplacement" colour="#4CAF50">
    <block type="move_forward"></block>
    <block type="turn_left"></block>
    <block type="turn_right"></block>
  </category>
</xml>`;

// Injection Blockly
const workspace = Blockly.inject('blocklyDiv', {
  toolbox: toolbox,
  trashcan: true
});

// Play = exécuter Blockly
async function runBlockly(){
  if(robots.length===0){ alert("Ajoute un robot !"); return; }
  const sel = document.getElementById("robotSelect");
  const selectedRobotId = parseInt(sel.value);
  const code = Blockly.JavaScript.workspaceToCode(workspace);

  const AsyncFn = Object.getPrototypeOf(async function(){}).constructor;
  const fullCode = `
      async function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
      ${code}
  `;
  const fn = new AsyncFn("robot_api","selectedRobotId", fullCode);
  fn(window.robot_api, selectedRobotId);
}

// Mise à jour liste robots
function updateRobotDropdown(){
  const sel = document.getElementById("robotSelect");
  sel.innerHTML = "";
  robots.forEach((r,i)=>{
    sel.innerHTML += `<option value="${i}">Robot ${i}</option>`;
  });
}
</script>

</body>
</html>