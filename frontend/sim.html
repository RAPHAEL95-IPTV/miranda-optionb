<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simulateur 3D — Robots + Blockly (corrigé)</title>

<!-- Blockly CSS (important pour voir les blocs) -->
<link rel="stylesheet" href="https://unpkg.com/blockly/media/blockly.css">

<style>
  :root { --bg:#111; --panel:#222; --accent:#0af; --muted:#999; }
  body{margin:0;background:var(--bg);color:#fff;font-family:Arial,Helvetica,sans-serif}
  header{padding:10px;background:var(--panel);border-bottom:2px solid var(--accent);color:var(--accent)}
  .layout{display:flex;min-height:calc(100vh - 46px)}
  #left{flex:1; padding:10px; box-sizing:border-box}
  #right{width:420px;padding:10px;box-sizing:border-box;border-left:1px solid rgba(255,255,255,0.03)}
  #sim_container{width:100%;height:640px;background:#222;display:flex;align-items:center;justify-content:center;border-radius:6px;overflow:hidden}
  canvas{display:block}
  .toolbar{margin:8px 0 12px 0;display:flex;gap:8px;align-items:center}
  .toolbar button{background:var(--accent);border:none;color:#000;padding:8px 12px;border-radius:6px;cursor:pointer}
  .toolbar button.ghost{background:transparent;color:#fff;border:1px solid rgba(255,255,255,0.06)}
  #robotSelect{width:160px;padding:8px;border-radius:6px;background:#111;color:#fff;border:1px solid rgba(255,255,255,0.04)}
  #runBtn{margin-left:6px;padding:10px 14px;border-radius:6px;background:#0f0;color:#000;border:none;cursor:pointer}
  #note{font-size:13px;color:var(--muted);margin-top:8px}
  #blocklyDiv{width:100%;height:560px;background:var(--panel);border-radius:6px}
  footer{padding:10px;color:var(--muted);font-size:13px;text-align:center}
</style>
</head>
<body>
<header><strong>Simulateur 3D — Robots</strong>  (corrigé)</header>

<div class="layout">
  <div id="left">
    <div class="toolbar">
      <button id="btnAddB">➕ Ajouter Robot B (Wall-E)</button>
      <button id="btnAddC">➕ Ajouter Robot C (Futuriste)</button>
      <button id="btnReset" class="ghost">♻ Réinitialiser</button>
      <select id="robotSelect" title="Robot contrôlé"></select>
      <button id="runBtn">▶ PLAY</button>
    </div>

    <div id="sim_container">
      <!-- canvas injected here -->
    </div>

    <div id="note">Ajoute un robot, sélectionne-le, crée un bloc "Avancer" puis clique PLAY.</div>
  </div>

  <div id="right">
    <div id="blocklyDiv"></div>
  </div>
</div>

<footer>Version locale — sans Cannon (animation simple) — blocs visibles.</footer>

<!-- libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://unpkg.com/blockly/blockly.min.js"></script>

<script>
/* ----------------------------
   SIMULATEUR (Three.js seulement)
   - robots: array of { mesh }
   - animations queue processed in animate()
   ---------------------------- */
const container = document.getElementById('sim_container');
let renderer, scene, camera, robots = [], animations = [];

/* start scene and renderer */
function startSim(){
  const W = container.clientWidth || 800;
  const H = container.clientHeight || 640;

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(60, W/H, 0.1, 1000);
  camera.position.set(6,6,6);
  camera.lookAt(0,0,0);

  // remove old canvas if any (robustness)
  const old = container.querySelector('canvas');
  if(old) old.remove();

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(W, H);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setClearColor(0x222222);
  container.appendChild(renderer.domElement);

  // lights
  const dir = new THREE.DirectionalLight(0xffffff, 1.4);
  dir.position.set(5,10,5); scene.add(dir);
  scene.add(new THREE.AmbientLight(0xcccccc, 0.6));

  // floor + grid
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(40,40),
    new THREE.MeshStandardMaterial({color:0x5a5a5a})
  );
  floor.rotation.x = -Math.PI/2; scene.add(floor);
  const grid = new THREE.GridHelper(40,40,0x444444,0x333333);
  scene.add(grid);

  window.addEventListener('resize', onResize);

  // ensure there's at least one robot visible
  if(robots.length === 0){
    addRobotB();
  }
  updateRobotDropdown();

  animate();
}
function onResize(){
  if(!renderer || !camera) return;
  const W = container.clientWidth || 800;
  const H = container.clientHeight || 640;
  renderer.setSize(W,H);
  camera.aspect = W/H;
  camera.updateProjectionMatrix();
}

/* robot creation (mesh only) */
function addRobotB(){
  const geo = new THREE.BoxGeometry(1,1,1);
  const mat = new THREE.MeshStandardMaterial({color:0xffdd66});
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(0,0.5,0);
  mesh.rotation.order = 'YXZ';
  scene.add(mesh);
  robots.push({mesh});
  console.log('Added Robot B, total robots=', robots.length);
  updateRobotDropdown();
}
function addRobotC(){
  const geo = new THREE.ConeGeometry(0.5,1,4);
  const mat = new THREE.MeshStandardMaterial({color:0x66aaff});
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(2,0.5,0);
  mesh.rotation.order = 'YXZ';
  scene.add(mesh);
  robots.push({mesh});
  console.log('Added Robot C, total robots=', robots.length);
  updateRobotDropdown();
}
function resetSim(){
  robots.forEach(r => { if(r.mesh) scene.remove(r.mesh); });
  robots = [];
  animations = [];
  console.log('Reset simulation');
  updateRobotDropdown();
}

/* animation queue helpers (no physics) */
function pushMove(id, dist, durationMs = 400){
  const r = robots[id];
  if(!r) { console.warn('pushMove: invalid id', id); return; }
  const steps = Math.max(1, Math.round((durationMs/1000) * 60));
  const angle = r.mesh.rotation.y;
  const dx = Math.sin(angle) * (dist / steps) * 0.01;
  const dz = Math.cos(angle) * (dist / steps) * 0.01;
  animations.push({type:'move', id, stepsLeft:steps, dx, dz});
}
function pushTurn(id, deg, durationMs = 300){
  const r = robots[id];
  if(!r) { console.warn('pushTurn: invalid id', id); return; }
  const steps = Math.max(1, Math.round((durationMs/1000) * 60));
  const da = (deg * Math.PI/180) / steps;
  animations.push({type:'turn', id, stepsLeft:steps, da});
}

/* animate loop */
function animate(){
  requestAnimationFrame(animate);

  for(let i = animations.length - 1; i >= 0; i--){
    const a = animations[i];
    const r = robots[a.id];
    if(!r || !r.mesh){ animations.splice(i,1); continue; }
    if(a.type === 'move'){
      r.mesh.position.x += a.dx;
      r.mesh.position.z += a.dz;
      a.stepsLeft--;
    } else if(a.type === 'turn'){
      r.mesh.rotation.y += a.da;
      a.stepsLeft--;
    }
    if(a.stepsLeft <= 0) animations.splice(i,1);
  }

  renderer.render(scene, camera);
}

/* dropdown helpers */
function updateRobotDropdown(){
  const sel = document.getElementById('robotSelect');
  if(!sel) return;
  sel.innerHTML = '';
  robots.forEach((r,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.text = `Robot ${i}`;
    sel.appendChild(opt);
  });
  if(robots.length > 0 && sel.selectedIndex === -1) sel.selectedIndex = 0;
}
function getSelectedRobot(){
  const sel = document.getElementById('robotSelect');
  if(!sel) return 0;
  if(robots.length === 0) return 0;
  if(sel.selectedIndex < 0) sel.selectedIndex = 0;
  const v = parseInt(sel.value);
  return isNaN(v) ? 0 : v;
}

/* expose small API for blocks */
window.pushMove = pushMove;
window.pushTurn = pushTurn;
window.getSelectedRobot = getSelectedRobot;

/* start */
startSim();

/* ============================
   BLOCKLY SETUP
   - define blocks first, then inject (so toolbox shows them)
   ============================ */

const toolboxXml = `
<xml xmlns="https://developers.google.com/blockly/xml">
  <category name="Mouvement" colour="#4CAF50">
    <block type="move_forward"></block>
    <block type="turn_right"></block>
    <block type="turn_left"></block>
  </category>
  <category name="Contrôle" colour="#4A148C">
    <block type="controls_repeat_ext">
      <value name="TIMES"><shadow type="math_number"><field name="NUM">2</field></shadow></value>
    </block>
  </category>
</xml>
`;

Blockly.defineBlocksWithJsonArray([
  {
    "type":"move_forward",
    "message0":"Avancer %1 px",
    "args0":[{"type":"field_number","name":"DIST","value":50}],
    "previousStatement":null,"nextStatement":null,"colour":120
  },
  {
    "type":"turn_right",
    "message0":"Tourner à droite %1°",
    "args0":[{"type":"field_angle","name":"ANGLE","angle":"90"}],
    "previousStatement":null,"nextStatement":null,"colour":200
  },
  {
    "type":"turn_left",
    "message0":"Tourner à gauche %1°",
    "args0":[{"type":"field_angle","name":"ANGLE","angle":"90"}],
    "previousStatement":null,"nextStatement":null,"colour":200
  }
]);

Blockly.JavaScript['move_forward'] = function(block){
  const dist = Number(block.getFieldValue('DIST')) || 0;
  // call pushMove at execution time using selected robot id
  return `window.pushMove(window.getSelectedRobot(), ${dist});\n`;
};
Blockly.JavaScript['turn_right'] = function(block){
  const a = Number(block.getFieldValue('ANGLE')) || 0;
  return `window.pushTurn(window.getSelectedRobot(), ${a});\n`;
};
Blockly.JavaScript['turn_left'] = function(block){
  const a = Number(block.getFieldValue('ANGLE')) || 0;
  return `window.pushTurn(window.getSelectedRobot(), ${-a});\n`;
};

const workspace = Blockly.inject('blocklyDiv',{
  toolbox: toolboxXml,
  trashcan: true,
  scrollbars: true
});

/* run button executes code generated by workspace */
document.getElementById('runBtn').addEventListener('click', () => {
  if(robots.length === 0){ alert('Ajoute d\'abord un robot.'); return; }
  updateRobotDropdown(); // sync
  const code = Blockly.JavaScript.workspaceToCode(workspace);
  try {
    const AsyncFn = Object.getPrototypeOf(async function(){}).constructor;
    const fn = new AsyncFn(code);
    fn();
  } catch (e){
    console.error('Erreur exécution Blockly:', e);
    alert('Erreur — regarde la console.');
  }
});

/* UI buttons wiring (safety: use addEventListener to avoid inline issues) */
document.getElementById('btnAddB').addEventListener('click', ()=>{ addRobotB(); updateRobotDropdown(); });
document.getElementById('btnAddC').addEventListener('click', ()=>{ addRobotC(); updateRobotDropdown(); });
document.getElementById('btnReset').addEventListener('click', ()=>{ resetSim(); updateRobotDropdown(); });

</script>
</body>
</html>
```0