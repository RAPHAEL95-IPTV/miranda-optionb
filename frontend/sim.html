<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Simulateur 3D Robots — B & C (Blockly intégré)</title>

<style>
  body{margin:0;background:#111;color:#fff;font-family:Arial}
  h2{margin:0;padding:10px;background:#222;color:#0af;border-bottom:2px solid #0af}
  /* layout */
  #leftPane { width: calc(100% - 440px); float:left; box-sizing:border-box; padding:0; }
  #rightPane { width:420px; float:right; box-sizing:border-box; padding:10px; height:100vh; }
  #toolbar{padding:10px;background:#000;border-bottom:1px solid #333}
  #toolbar button{padding:8px 14px;margin-right:6px;background:#0af;border:none;color:#fff;border-radius:4px;cursor:pointer}
  #toolbar button:hover{background:#08c}

  #sim_container{width:100%;height:600px;position:relative;background:#000}
  canvas{background:#000;display:block;margin:auto}

  #blocklyDiv{
    width:100%; height:calc(100vh - 120px); background:#222; border:2px solid #0af; border-radius:8px;
  }
  #controls { margin-top:8px; display:flex; gap:8px; align-items:center; justify-content:space-between; }
  #robotSelect{ padding:8px; border-radius:4px; background:#111; color:#fff; border:1px solid #333; width:60%; }
  #runBtn{ padding:10px 16px; background:#0f0; color:#000; border:none; border-radius:6px; cursor:pointer; font-weight:bold; }
  #runBtn:hover{ background:#9f9; }
  /* small note */
  .note{ font-size:12px;color:#bbb;margin-top:8px }
</style>

<!-- Blockly -->
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/blockly/media/blockly.css">
</head>
<body>
<h2 style="padding-left:10px">Simulateur 3D — Robots B & C (Blockly à droite)</h2>

<div id="leftPane">
  <div id="toolbar">
    <button id="btnAddB">➕ Ajouter Robot B (Wall-E)</button>
    <button id="btnAddC">➕ Ajouter Robot C (Futuriste)</button>
    <button id="btnReset">♻ Réinitialiser</button>
  </div>

  <div id="sim_container">
    <canvas id="sim" width="800" height="600"></canvas>
  </div>
</div>

<div id="rightPane">
  <div style="display:flex;align-items:center;gap:8px;justify-content:space-between;">
    <div style="flex:1">
      <label style="font-size:13px;color:#ddd">Robot à contrôler</label><br>
      <select id="robotSelect"></select>
    </div>
    <div>
      <button id="runBtn">▶ PLAY</button>
    </div>
  </div>

  <div id="blocklyDiv" aria-label="Éditeur Blockly"></div>

  <div class="note">Ajoute un robot puis choisis-le dans la liste avant d’exécuter.</div>
</div>

<script>
/* ============================
   PARTIE 1 — SIMULATEUR (INCHANGÉ)
   ============================ */

const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d');

let camX = 0, camY = 0, camZoom = 1, camRot = 0;
let isRightDragging=false, isLeftDragging=false, lastMouseX=0, lastMouseY=0;

let robots = []; // tableau des robots

function createRobotB(){
  return {
    type:"B",
    x: Math.random()*500+100,
    y: Math.random()*300+150,
    angle: 0,
    size: 40,
    color:"#ffdd66",
    wheelsColor:"#444",
    eyeColor:"#fff"
  };
}
function createRobotC(){
  return {
    type:"C",
    x: Math.random()*500+100,
    y: Math.random()*300+150,
    angle: 0,
    size: 45,
    color:"#66aaff",
    neon:"#0ff"
  };
}

/* Fonctions publiques telles qu'initialement */
function addRobotB(){ robots.push(createRobotB()); }
function addRobotC(){ robots.push(createRobotC()); }
function resetSim(){ robots = []; }

/* window.robot_api : complété plus bas */
window.robot_api = window.robot_api || {};

/* DESSIN */
function drawRobotB(r){
  ctx.save();
  ctx.translate(r.x, r.y);
  ctx.rotate(r.angle);

  ctx.fillStyle = r.color;
  ctx.fillRect(-r.size/2, -r.size/2, r.size, r.size);

  ctx.fillRect(-r.size/3, -r.size*0.9, r.size*0.66, r.size*0.5);

  ctx.fillStyle = r.eyeColor;
  ctx.beginPath();
  ctx.arc(-10, -r.size*0.7, 6, 0, Math.PI*2);
  ctx.arc(10, -r.size*0.7, 6, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = r.wheelsColor;
  ctx.fillRect(-r.size/2-6, -r.size/3, 6, r.size*0.66);
  ctx.fillRect(r.size/2, -r.size/3, 6, r.size*0.66);

  ctx.restore();
}
function drawRobotC(r){
  ctx.save();
  ctx.translate(r.x, r.y);
  ctx.rotate(r.angle);

  ctx.fillStyle = r.color;
  ctx.beginPath();
  ctx.moveTo(0, -r.size/1.2);
  ctx.lineTo(-r.size/1.3, r.size/1.2);
  ctx.lineTo(r.size/1.3, r.size/1.2);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = r.neon;
  ctx.fillRect(-8, -r.size*0.2, 16, 6);

  ctx.restore();
}

/* NAVIGATION */
canvas.addEventListener('contextmenu', e=>e.preventDefault());
canvas.addEventListener('mousedown', e=>{
  if(e.button===2) isRightDragging=true;
  if(e.button===0) isLeftDragging=true;
  lastMouseX = e.clientX; lastMouseY = e.clientY;
});
canvas.addEventListener('mouseup', e=>{
  if(e.button===2) isRightDragging=false;
  if(e.button===0) isLeftDragging=false;
});
canvas.addEventListener('mousemove', e=>{
  const dx = e.clientX - lastMouseX;
  const dy = e.clientY - lastMouseY;
  if(isRightDragging){ camX += dx / camZoom; camY += dy / camZoom; }
  if(isLeftDragging){ camRot += dx * 0.01; }
  lastMouseX = e.clientX; lastMouseY = e.clientY;
});
canvas.addEventListener('wheel', e=>{
  if(e.deltaY < 0) camZoom *= 1.1; else camZoom /= 1.1;
});

/* ANIMATIONS: file d'animations géré dans la boucle de rendu
   (on pousse des "tasks" ici et la boucle de rendu les applique)
*/
let animations = []; // chaque animation: {type, id, stepsLeft, dx, dy, da}

function pushMoveAnimation(id, dist, durationMs=400){
  const r = robots[id];
  if(!r) return;
  const fps = 60;
  const steps = Math.max(1, Math.round((durationMs/1000) * fps));
  const dx = Math.cos(r.angle) * (dist / steps);
  const dy = Math.sin(r.angle) * (dist / steps);
  animations.push({ type:'move', id, stepsLeft:steps, dx, dy });
}
function pushTurnAnimation(id, deg, durationMs=300){
  const r = robots[id];
  if(!r) return;
  const fps = 60;
  const steps = Math.max(1, Math.round((durationMs/1000) * fps));
  const da = (deg * Math.PI/180) / steps;
  animations.push({ type:'turn', id, stepsLeft:steps, da });
}

/* BOUCLE RENDU et application des animations */
function loop(){
  // appliquer animations
  for(let i = animations.length - 1; i >= 0; i--){
    const a = animations[i];
    const r = robots[a.id];
    if(!r){ animations.splice(i,1); continue; }
    if(a.type === 'move'){
      r.x += a.dx; r.y += a.dy;
      a.stepsLeft--;
    } else if(a.type === 'turn'){
      r.angle += a.da;
      a.stepsLeft--;
    }
    if(a.stepsLeft <= 0) animations.splice(i,1);
  }

  // rendu
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.scale(camZoom, camZoom);
  ctx.rotate(camRot);
  ctx.translate(-canvas.width/2 + camX, -canvas.height/2 + camY);

  robots.forEach(r=>{
    if(r.type === 'B') drawRobotB(r);
    if(r.type === 'C') drawRobotC(r);
  });

  ctx.restore();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ============================
   PARTIE 2 — BLOCKLY + LIAISON (AJOUTS NON INTRUSIFS)
   ============================ */

/* Hook boutons UI: on appelle les fonctions existantes, puis on update dropdown */
document.getElementById('btnAddB').addEventListener('click', ()=>{
  addRobotB(); updateRobotDropdown();
});
document.getElementById('btnAddC').addEventListener('click', ()=>{
  addRobotC(); updateRobotDropdown();
});
document.getElementById('btnReset').addEventListener('click', ()=>{
  resetSim(); updateRobotDropdown();
});

/* Mise à jour dropdown robot (Option 1: Robot 0, Robot 1, ...) */
function updateRobotDropdown(){
  const sel = document.getElementById('robotSelect');
  sel.innerHTML = '';
  robots.forEach((r,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.text = `Robot ${i}`;
    sel.appendChild(opt);
  });
  if(robots.length > 0 && sel.selectedIndex === -1) sel.selectedIndex = 0;
}

/* getSelectedRobot — toujours renvoie un index valide (0 si pas de robots) */
function getSelectedRobot(){
  const sel = document.getElementById('robotSelect');
  if(!sel) return 0;
  if(robots.length === 0) return 0;
  if(sel.selectedIndex < 0) sel.selectedIndex = 0;
  const v = parseInt(sel.value);
  return isNaN(v) ? 0 : v;
}

/* Définition des blocs AVANT injection (obligatoire pour toolbox visible) */
Blockly.defineBlocksWithJsonArray([
  {
    "type": "move_forward",
    "message0": "Avancer de %1 px",
    "args0": [{"type":"field_number","name":"DIST","value":50}],
    "previousStatement":null,"nextStatement":null,"colour":120
  },
  {
    "type": "turn_left",
    "message0": "Tourner à gauche de %1°",
    "args0": [{"type":"field_number","name":"ANGLE","value":90}],
    "previousStatement":null,"nextStatement":null,"colour":200
  },
  {
    "type": "turn_right",
    "message0": "Tourner à droite de %1°",
    "args0": [{"type":"field_number","name":"ANGLE","value":90}],
    "previousStatement":null,"nextStatement":null,"colour":200
  }
]);

/* Générateurs JS — NOTE : on appelle getSelectedRobot() à l'exécution */
Blockly.JavaScript['move_forward'] = function(block){
  const dist = Number(block.getFieldValue('DIST')) || 0;
  // On produit du code qui, lorsqu'il est évalué, lancera l'animation
  return `pushMoveAnimation(${getSelectedRobot()}, ${dist});\n`;
};
Blockly.JavaScript['turn_left'] = function(block){
  const a = Number(block.getFieldValue('ANGLE')) || 0;
  return `pushTurnAnimation(${getSelectedRobot()}, ${-a});\n`;
};
Blockly.JavaScript['turn_right'] = function(block){
  const a = Number(block.getFieldValue('ANGLE')) || 0;
  return `pushTurnAnimation(${getSelectedRobot()}, ${a});\n`;
};

/* Toolbox + injection */
const toolbox = `
<xml xmlns="https://developers.google.com/blockly/xml">
  <category name="Déplacement" colour="#4CAF50">
    <block type="move_forward"></block>
    <block type="turn_left"></block>
    <block type="turn_right"></block>
  </category>
</xml>`;
const workspace = Blockly.inject('blocklyDiv', { toolbox: toolbox, trashcan:true });

/* Exécution du code Blockly (PLAY)
   - update dropdown avant exécution pour s'assurer que la sélection est à jour
   - code généré utilise pushMoveAnimation/pushTurnAnimation que nous avons défini ci-dessus
*/
document.getElementById('runBtn').addEventListener('click', ()=>{
  if(robots.length === 0){ alert("Ajoute d'abord un robot (bouton Ajouter Robot B ou C)."); return; }
  updateRobotDropdown();
  // Generate code and eval it
  const code = Blockly.JavaScript.workspaceToCode(workspace);
  try{
    // small safety: limit length
    if(code.length > 20000){ alert("Programme trop long."); return; }
    eval(code);
  }catch(e){
    console.error("Erreur exécution Blockly:", e);
    alert("Erreur lors de l'exécution du programme (voir console).");
  }
});

/* Expose pushMoveAnimation/pushTurnAnimation globalement pour les blocs */
window.pushMoveAnimation = pushMoveAnimation;
window.pushTurnAnimation = pushTurnAnimation;

/* update dropdown initially (empty) */
updateRobotDropdown();

/* petite boucle qui assure que si robots sont ajoutés par d'autres scripts, la dropdown s'update */
setInterval(()=>{ updateRobotDropdown(); }, 800);

</script>
</body>
</html>