<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Simulateur 3D Robots + Blockly</title>
<style>
  body{margin:0;background:#111;color:#fff;font-family:Arial}
  h2{margin:0;padding:10px;background:#222;color:#0af;border-bottom:2px solid #0af}
  #toolbar{padding:10px;background:#000;border-bottom:1px solid #333}
  #toolbar button{padding:8px 14px;margin-right:6px;background:#0af;border:none;color:#fff;border-radius:4px;cursor:pointer}
  #toolbar button:hover{background:#08c}
  #sim_container{width:100%;height:600px;position:relative;background:#000}
  canvas{background:#000;display:block;margin:auto}
  #blocklyDiv{height:400px;width:100%;border:1px solid #444;margin-top:10px;}
  #runBlocks{padding:8px 16px;margin-top:6px;background:#0af;color:#fff;border:none;border-radius:4px;cursor:pointer;}
</style>
</head>

<body>
<h2>Simulateur 3D — Robots B & C + Blockly</h2>

<div id="toolbar">
  <button onclick="addRobotB()">➕ Ajouter Robot B (Wall-E)</button>
  <button onclick="addRobotC()">➕ Ajouter Robot C (Futuriste)</button>
  <button onclick="resetSim()">♻ Réinitialiser</button>
</div>

<div id="sim_container"></div>

<!-- Blockly -->
<div id="blocklyDiv"></div>
<button id="runBlocks">▶ Play</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
<script src="https://unpkg.com/blockly/blockly.min.js"></script>

<script>
// ------------------ SIMULATEUR 3D ------------------
let scene, camera, renderer, world, robots=[];
const container = document.getElementById('sim_container');

function startSim(){
  const W = container.clientWidth||800, H=container.clientHeight||600;
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60,W/H,0.1,1000);
  camera.position.set(6,4,6); camera.lookAt(0,0,0);
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(W,H);
  container.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff,1.2); light.position.set(5,10,5); scene.add(light);
  scene.add(new THREE.AmbientLight(0x666666,0.6));

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(40,40), new THREE.MeshStandardMaterial({color:0x303030}));
  floor.rotation.x = -Math.PI/2; scene.add(floor);

  world = new CANNON.World();
  world.gravity.set(0,-9.82,0);
  const groundBody = new CANNON.Body({mass:0});
  groundBody.addShape(new CANNON.Plane());
  groundBody.quaternion.setFromEuler(-Math.PI/2,0,0);
  world.addBody(groundBody);

  animate();
}

function addRobotB(){
  const geo = new THREE.BoxGeometry(1,1,1);
  const mat = new THREE.MeshStandardMaterial({color:0xffdd66});
  const mesh = new THREE.Mesh(geo,mat); mesh.position.set(0,1,0); scene.add(mesh);
  const body = new CANNON.Body({mass:1});
  body.addShape(new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5)));
  body.position.set(0,1,0); world.addBody(body);
  robots.push({mesh, body});
}

function addRobotC(){
  const geo = new THREE.ConeGeometry(0.5,1,4);
  const mat = new THREE.MeshStandardMaterial({color:0x66aaff});
  const mesh = new THREE.Mesh(geo,mat); mesh.position.set(2,1,0); scene.add(mesh);
  const body = new CANNON.Body({mass:1});
  body.addShape(new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5)));
  body.position.set(2,1,0); world.addBody(body);
  robots.push({mesh, body});
}

function resetSim(){
  robots.forEach(r=>{
    if(r.mesh) scene.remove(r.mesh);
    if(r.body) world.removeBody(r.body);
  });
  robots=[]; 
}

function animate(){
  requestAnimationFrame(animate);
  world.step(1/60);
  robots.forEach(r=>{
    if(r.body && r.mesh){
      r.mesh.position.copy(r.body.position);
      r.mesh.quaternion.copy(r.body.quaternion);
    }
  });
  renderer.render(scene,camera);
}

// API Blockly
window.robot_api = {
  move: function(id,dist){
    if(!robots[id]||!robots[id].body) return;
    const body = robots[id].body;
    const angle = body.quaternion.toEuler().y || 0;
    const dx = Math.sin(angle)*dist*0.01;
    const dz = Math.cos(angle)*dist*0.01;
    body.position.x += dx;
    body.position.z += dz;
  },
  turn: function(id,deg){
    if(!robots[id]||!robots[id].body) return;
    const body = robots[id].body;
    const euler = body.quaternion.toEuler();
    euler.y += deg * Math.PI/180;
    body.quaternion.setFromEuler(euler.x,euler.y,euler.z);
  }
};

// THREE quaternion helper
CANNON.Quaternion.prototype.toEuler = function(){
  const q=this;
  const ysqr = q.y*q.y;
  const t0 = +2.0*(q.w*q.x + q.y*q.z);
  const t1 = +1.0 - 2.0*(q.x*q.x + ysqr);
  const X = Math.atan2(t0,t1);
  const t2 = +2.0*(q.w*q.y - q.z*q.x);
  const t2Clamped = Math.min(Math.max(t2,-1),1);
  const Y = Math.asin(t2Clamped);
  const t3 = +2.0*(q.w*q.z + q.x*q.y);
  const t4 = +1.0 - 2.0*(ysqr + q.z*q.z);
  const Z = Math.atan2(t3,t4);
  return {x:X,y:Y,z:Z};
};

startSim();

// ------------------ BLOCKLY ------------------
const workspace = Blockly.inject('blocklyDiv',{
  toolbox: `
    <xml xmlns="https://developers.google.com/blockly/xml">
      <block type="move_forward"></block>
      <block type="turn"></block>
    </xml>
  `
});

// Définition des blocs
Blockly.Blocks['move_forward'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("Avancer de")
        .appendField(new Blockly.FieldNumber(50, 1, 500), "DIST")
        .appendField("px");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(120);
  }
};
Blockly.JavaScript['move_forward'] = function(block) {
  const dist = Number(block.getFieldValue('DIST'));
  return `robot_api.move(0, ${dist});\n`;
};

Blockly.Blocks['turn'] = {
  init: function() {
    this.appendDummyInput()
        .appendField("Tourner de")
        .appendField(new Blockly.FieldAngle(90), "ANGLE")
        .appendField("°");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
  }
};
Blockly.JavaScript['turn'] = function(block) {
  const deg = Number(block.getFieldValue('ANGLE'));
  return `robot_api.turn(0, ${deg});\n`;
};

// Bouton Play
document.getElementById('runBlocks').addEventListener('click', ()=>{
  const code = Blockly.JavaScript.workspaceToCode(workspace);
  try{
    const AsyncFn = Object.getPrototypeOf(async function(){}).constructor;
    const fn = new AsyncFn("robot_api", code);
    fn(window.robot_api);
  }catch(e){ console.error("Erreur Blockly:", e);}
});
</script>
</body>
</html>