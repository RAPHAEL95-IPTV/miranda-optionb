<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Simulation 3D</title>

<style>
  body {
    margin: 0;
    background: #111;
    color: white;
    font-family: Arial;
  }

  #sim_container {
    width: 100%;
    height: 600px !important;
    min-height: 600px;
    border: 2px solid #333;
    background: #000;
    box-sizing: border-box;
  }
</style>

</head>
<body>

<h2 style="padding:10px;">Simulateur 3D – Robots</h2>
<div id="sim_container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://unpkg.com/cannon-es/dist/cannon-es.js"></script>

<script>
let scene, camera, renderer, world, robots = [];

/*------------------------------------------
  INITIALISATION
-------------------------------------------*/
function init() {
  const container = document.getElementById('sim_container');

  // FIX : garantie que le conteneur ait une vraie taille
  const W = container.clientWidth;
  const H = container.clientHeight;
  console.log("Taille conteneur:", W, H);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, W / H, 0.1, 1000);
  camera.position.set(6, 4, 6);
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(W, H);
  container.appendChild(renderer.domElement);

  // LUMIÈRE FIX
  const light = new THREE.DirectionalLight(0xffffff, 1.2);
  light.position.set(5, 10, 5);
  scene.add(light);

  // sol visuel
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(40, 40),
    new THREE.MeshStandardMaterial({ color: 0x404040 })
  );
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);

  // Physique
  world = new CANNON.World();
  world.gravity.set(0, -9.82, 0);

  const groundBody = new CANNON.Body({
    mass: 0,
    shape: new CANNON.Plane()
  });
  groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
  world.addBody(groundBody);

  // Ajoute 1 robot (test)
  addRobot(0, 1, 0);

  animate();
}

/*------------------------------------------
  AJOUT ROBOT
-------------------------------------------*/
function addRobot(x, y, z) {
  const geo = new THREE.BoxGeometry(1, 1, 1);
  const mat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, z);
  scene.add(mesh);

  const body = new CANNON.Body({
    mass: 1,
    shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)),
    position: new CANNON.Vec3(x, y, z)
  });
  world.addBody(body);

  robots.push({ mesh, body });
}

/*------------------------------------------
  ANIMATION
-------------------------------------------*/
function animate() {
  requestAnimationFrame(animate);

  world.step(1 / 60);
  robots.forEach(r => {
    r.mesh.position.copy(r.body.position);
    r.mesh.quaternion.copy(r.body.quaternion);
  });

  renderer.render(scene, camera);
}

/*------------------------------------------
  API pour Blockly
-------------------------------------------*/
const robot_api = {
  move(dist, id = 0) {
    if (!robots[id]) return;
    const forward = new CANNON.Vec3(0, 0, -1);
    robots[id].body.applyImpulse(forward.scale(dist * 0.5), robots[id].body.position);
  },

  turn(angle, id = 0) {
    if (!robots[id]) return;
    robots[id].body.angularVelocity.set(0, angle * 0.02, 0);
  }
};

window.addEventListener("message", ev => {
  if (!ev.data || ev.data.type !== "run_code") return;
  const code = ev.data.code;

  const AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;
  const fn = new AsyncFunction("robot_api", code);
  fn(robot_api).catch(console.error);
});

init();
</script>

</body>
</html>